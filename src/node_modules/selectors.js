import * as R from 'ramda'

//--------------------------
//находим все телефоны по id из state.phones
export const getPhoneById = (state, id) => R.prop(id, state.phones) //state.phones[id]

//====================================
//здесь промэпили все данные и записали в phones
export const getPhones = (state, ownProps) => {
  // contains проверяет что первый аргумент R.prop('name', item) находится внутри второго аргумента state.phonesPage.search
  //.toLowerCase()
  // item.label.toLowerCase()
    // .indexOf(term.toLowerCase()) > -1;
  const applySearch = item => R.contains( //item - каждый элемент, проходим по элементам  (R.contains - проверяет перваый аргумент  state.phonesPage.search,находится внутри второго аргумента R.prop('name', item) (возвращает true - false)
    state.phonesPage.search,  //т.е.выбираем те тел. , которые подходят к запросу search - если нет совпадения, то по умолчанию search = '', пустая строка, которая имеется в любой строке и вернет true
    // item.name.toLowerCase(), //в нижнем регистре
    R.prop('name', item) //получаем имя тел, в соответствии регистре 
  )
// --------------------------
  //Фильтрация по активным категориям - выбираем товары активной категории
  const activeCategoryId = getActiveCategoryId(ownProps)
  
    const applyCategory = item => R.equals(
      activeCategoryId,
      R.prop('categoryId', item)
    )

//-------------------------------
  const phones = R.compose(
    //данные state.phonesPage.ids будут вызываться на R.map(id => getPhoneById(state, id), и применяем фильтр applySearch
    R.filter(applySearch),  // т.е. выбрасываем те тел, которые в имени не содержат в именах search - подстрока

    //R.when() выполнится вторая функция, когда первая функция true
    R.when(R.always(activeCategoryId), R.filter(applyCategory)),

    R.map(id => getPhoneById(state, id)) //в строке
  )(state.phonesPage.ids)
  // const phones = R.map(id => getPhoneById(state, id), state.phonesPage.ids)
  return phones
}
//=========================
//получаем длину данных телефонов в state
export const getRenderedPhonesLength = state => R.length(state.phonesPage.ids)

// -----------------------------
//получаем книги по id
export const getBookById = (state, id) => R.prop(id, state.books)

//map-им книги по id
export const getBooksSelector = state => {
  const books = R.map(id => getBookById(state, id), state.booksIds.ids)
  return books
}

export const getTotalBasketCount = state => R.length(state.basket)

export const getTotalBasketPrice = state => {
  const totalPrice = R.compose(
    // методы выполняются снизу вверх
    R.sum,  // суммируем цены
    R.pluck('price'),   //с каждого объекта вытаскиваем цену - получаем массив цен
    R.map(id => getPhoneById(state, id))  //получаем массив тел
  )(state.basket)

  return totalPrice
}

// ----------------------------
//R.values - получаем массив объекта
export const getCategories = state => R.values(state.categories)

// -----------------------------
//Получение id активной категории
export const getActiveCategoryId = ownProps => //R.path(['match', 'params', 'id'], ownProps)

{
  // ownProps.match.params.id
return R.path(['match', 'params', 'id'], ownProps) // match в console
  // R.path() - проверяет цепочку в массиве объектов ownProps, если какогото объекта нет, вернет undefine, а не ошибку (вначале ищем match затем params затем id)
}

// ------------------------------
//// товары с добавленными в корзину
export const getBasketPhonesWithCount = state => {

  const phoneCount = id => R.compose(
    R.length,
    R.filter(basketId => R.equals(id, basketId))
  )(state.basket) //получаем число отобранных товаров
//state.basket - id  хранящиеся в корзине
  const phoneWithCount = phone => R.assoc('count', phoneCount(phone.id), phone) //R.assoc() =  'count'- (phone.count) = 2) внутри phone

    // ------------
  const uniqueIds = R.uniq(state.basket)  //список id  уникальных (без повторений) товаров, - 1. - внчале получаем списо товаров с уникальными id, затем 
  const phones = R.compose(
    R.map(phoneWithCount),  //это предикат, который вызывается для каждого товара
    R.map(id => getPhoneById(state, id))  //мэпим все телефоны по имеющимся id
  )(uniqueIds)

  return phones
}





